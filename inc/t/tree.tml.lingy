{ "testml": "0.3.0",
  "code": [
    ["%<>",["*grammar","*input","*tree"],
      ["==",
        [".",
          ["parse-to-tree",
            ["*","grammar"],
            ["*","input"]],
          ["yaml"],
          ["clean"]],
        ["*","tree"],
        "+ - Pegex::Tree"]],
    ["%<>",["*grammar","*input","*wrap"],
      ["==",
        [".",
          ["parse-to-tree-wrap",
            ["*","grammar"],
            ["*","input"]],
          ["yaml"],
          ["clean"]],
        ["*","wrap"],
        "+ - Pegex::Tree::Wrap"]],
    ["%<>",["*grammar","*input","*ast"],
      ["==",
        [".",
          ["parse-to-tree-test",
            ["*","grammar"],
            ["*","input"]],
          ["yaml"],
          ["clean"]],
        ["*","ast"],
        "+ - t::TestAST"]]],
  "data": [
    { "label": "Single Regex - Single Capture",
      "point": {
        "grammar": "a: /x*(y*)z* EOL/\n",
        "input": "xxxyyyyzzz\n",
        "tree": "yyyy\n",
        "wrap": "a: yyyy\n"}},
    { "label": "Single Regex - Multi Capture",
      "point": {
        "grammar": "a: /(x*)(y*)(z*) EOL/\n",
        "input": "xxxyyyyzzz\n",
        "tree": "- xxx\n- yyyy\n- zzz\n",
        "wrap": "a:\n- xxx\n- yyyy\n- zzz\n"}},
    { "label": "Multi Group Regex",
      "point": {
        "grammar": "t: /.*(x).*(y).*(z).*/\n",
        "input": "aaaxbbbyccczddd",
        "tree": "- x\n- y\n- z\n",
        "wrap": "t:\n- x\n- y\n- z\n"}},
    { "label": "Single Regex - No Capture",
      "point": {
        "grammar": "a: /x*y*z* EOL/\n",
        "input": "xxxyyyyzzz\n",
        "tree": "[]\n",
        "wrap": "a: []\n"}},
    { "label": "Non capture Regex",
      "point": {
        "grammar": "a: b b* -c* .d*\nb: /b/\nc: /c+/\nd: /d/\n",
        "input": "bbccdd",
        "tree": "- []\n",
        "wrap": "a:\n- []\n"}},
    { "label": "A subrule",
      "point": {
        "grammar": "a: b /(y+)/ EOL\nb: /(x+)/\n",
        "input": "xxxyyyy\n",
        "tree": "- xxx\n- yyyy\n",
        "wrap": "a:\n- b: xxx\n- yyyy\n"}},
    { "label": "Multi match regex in subrule",
      "point": {
        "grammar": "a: b\nb: /(x*)y*(z*) EOL/\n",
        "input": "xxxyyyyzzz\n",
        "tree": "- xxx\n- zzz\n",
        "wrap": "a:\n  b:\n  - xxx\n  - zzz\n"}},
    { "label": "Any rule group",
      "point": {
        "grammar": "a: (b | c)\nb: /(bleh)/\nc: /(x*)y*(z*) EOL?/\n",
        "input": "xxxyyyyzzz\n",
        "tree": "- xxx\n- zzz\n",
        "wrap": "a:\n  c:\n  - xxx\n  - zzz\n"}},
    { "label": "+ Modifier",
      "point": {
        "grammar": "a: ( b c )+ EOL\nb: /(x*)/\nc: /(y+)/\n",
        "input": "xxyyxy\n",
        "tree": "- - - xx\n    - yy\n  - - x\n    - y\n",
        "wrap": "a:\n- - - b: xx\n    - c: yy\n  - - b: x\n    - c: y\n"}},
    { "label": "Wrap Pass and Skip",
      "point": {
        "grammar": "a: +b -c .d\nb: /(b+)/\nc: /(c+)/\nd: /(d+)/\n",
        "input": "bbccdd",
        "tree": "- b: bb\n- cc\n",
        "wrap": "a:\n- b: bb\n- c: cc\n"}},
    { "label": "Flat and Skip Multi",
      "point": {
        "grammar": "a: b* -c* .d*\nb: /(b)/\nc: /(c)/\nd: /(d)/\n",
        "input": "bccdd",
        "tree": "- - b\n- c\n- c\n",
        "wrap": "a:\n- - b: b\n- c: c\n- c: c\n"}},
    { "label": "Skip Bracketed",
      "point": {
        "grammar": "a: b .(c d)\nb: /(b)/\nc: /(c+)/\nd: /(d+)/\n",
        "input": "bcccd",
        "tree": "b\n",
        "wrap": "a:\n  b: b\n"}},
    { "label": "Assertions",
      "point": {
        "grammar": "a: !b =c c\nb: /b/\nc: /(c+)/\n",
        "input": "ccc",
        "tree": "ccc\n",
        "wrap": "a:\n  c: ccc\n"}},
    { "label": "Assertion not captured",
      "point": {
        "grammar": "a: =x x y EOL\nx: /(x+)/\ny: /(y+)/\n",
        "input": "xxxyyyy\n",
        "tree": "- xxx\n- yyyy\n",
        "wrap": "a:\n- x: xxx\n- y: yyyy\n"}},
    { "label": "Empty regex group plus rule",
      "point": {
        "grammar": "a: b* c EOL\nb: /xxx/\nc: /(yyy)/\n",
        "input": "xxxyyy\n",
        "tree": "- []\n- yyy\n",
        "wrap": "a:\n- []\n- c: yyy\n"}},
    { "label": "Rule to Rule to Rule",
      "point": {
        "grammar": "a: b\nb: c*\nc: d EOL\nd: /x(y)z/\n",
        "input": "xyz\nxyz\n",
        "tree": "- - y\n- - y\n",
        "wrap": "a:\n  b:\n  - c:\n    - d: y\n  - c:\n    - d: y\n"}},
    { "label": "List and Separators",
      "point": {
        "grammar": "a: b c+ % d\nb: /(b)/\nc: /(c+)/\nd: /(d+)/\n",
        "input": "bcccdccddc",
        "tree": "- b\n- - ccc\n  - d\n  - cc\n  - dd\n  - c\n",
        "wrap": "a:\n- b: b\n- - c: ccc\n  - d: d\n  - c: cc\n  - d: dd\n  - c: c\n"}},
    { "label": "Rule with Separator",
      "point": {
        "grammar": "a: c* % d\nc: /(c+)/\nd: /d+/\n",
        "input": "cccdccddc",
        "tree": "- ccc\n- cc\n- c\n",
        "wrap": "a:\n- c: ccc\n- c: cc\n- c: c\n"}},
    { "label": "List without Separators",
      "point": {
        "grammar": "a: b c* % d b\nb: /(b)/\nc: /(c+)/\nd: /d+/\n",
        "input": "bb",
        "tree": "- b\n- []\n- b\n",
        "wrap": "a:\n- b: b\n- []\n- b: b\n"}},
    { "label": "Whitespace Matchers",
      "point": {
        "grammar": "TOP: / ws*( DOT ) - ( DOT* ) -/\n",
        "input": "  .  \n     ..    \n",
        "tree": "- .\n- ..\n",
        "wrap": "TOP:\n- .\n- ..\n"}},
    { "label": "Automatically Pass TOP",
      "point": {
        "grammar": "b: /(b)/\nTOP: b c*\nc: /(c)/\n",
        "input": "bcc",
        "tree": "- b\n- - c\n  - c\n",
        "wrap": "TOP:\n- b: b\n- - c: c\n  - c: c\n"}},
    { "label": "Empty Stars",
      "point": {
        "grammar": "a: ( b* c )+ b*\nb: /(b)/\nc: /(c+)/\n",
        "input": "cc",
        "tree": "- - - []\n    - cc\n- []\n",
        "wrap": "a:\n- - - []\n    - c: cc\n- []\n"}},
    { "label": "Exact Quantifier",
      "point": {
        "grammar": "a: <b>3\nb: /(b)/\n",
        "input": "bbb",
        "tree": "- b\n- b\n- b\n",
        "wrap": "a:\n- b: b\n- b: b\n- b: b\n"}},
    { "label": "Quantifier with Separator",
      "point": {
        "grammar": "a: <b>2-4 %% /,/\nb: /(b)/\n",
        "input": "b,b,b,",
        "tree": "- b\n- b\n- b\n",
        "wrap": "a:\n- b: b\n- b: b\n- b: b\n"}},
    { "label": "Quantifier with Separator, Trailing OK",
      "point": {
        "grammar": "a: <b>2-4 %% /,/\nb: /(b)/\n",
        "input": "b,b,b,",
        "tree": "- b\n- b\n- b\n",
        "wrap": "a:\n- b: b\n- b: b\n- b: b\n"}},
    { "label": "Quantifier on the Separator",
      "point": {
        "grammar": "a: <b>2-4 %% c*\nb: /(b)/\nc: / COMMA /\n",
        "input": "b,b,,,,bb,",
        "tree": "- b\n- []\n- b\n- []\n- b\n- []\n- b\n",
        "wrap": "a:\n- b: b\n- []\n- b: b\n- []\n- b: b\n- []\n- b: b\n"}},
    { "label": "Tilde matching",
      "point": {
        "grammar": "a: - b + b+\nb: /(b)/\nc: / COMMA /\n",
        "input": "b  bb",
        "tree": "- b\n- - b\n  - b\n",
        "wrap": "a:\n- b: b\n- - b: b\n  - b: b\n"}},
    { "label": "False Values",
      "point": {
        "grammar": "a: zero empty undef\nzero: /(b+)/\nempty: /(c+)/\nundef: /(d+)/\n",
        "input": "bbccdd",
        "ast": "- 0\n- ''\n- null\n"}},
    { "label": "Wrap",
      "point": {
        "grammar": "a: b c d\nb: /(b+)/\nc: /(c+)/\nd: /(d+)/\n",
        "input": "bbccdd",
        "wrap": "a:\n- b: bb\n- c: cc\n- d: dd\n"}},
    { "label": "Separated Group",
      "point": {
        "grammar": "a: (b | c)+ % d\nb: /(b)/\nc: /(c)/\nd: /(d)/\n",
        "input": "bdcdb",
        "ast": "- b\n- d\n- c\n- d\n- b\n"}},
    { "label": "Separator Group",
      "point": {
        "grammar": "a: b+ %% (c | d)\nb: /(b)/\nc: /(c)/\nd: /(d)/\n",
        "input": "bdbcbc",
        "ast": "- b\n- d\n- b\n- c\n- b\n- c\n"}}]}
